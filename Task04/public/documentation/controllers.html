<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Description des contrôleurs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.2/styles/github.min.css">
  </head>
  <body>
    <h1>Description des contrôleurs</h1>
    <h2>Intérêt global</h2>
    <p>Les contrôleurs sont une couche d'abstraction au-dessus de l'<a href="(https://fr.wikipedia.org/wiki/Mapping_objet-relationnel)"><abbr title="Object-Relational Mapping">ORM</abbr></a> ; grâce à eux, on obtient un patron de conception <a href="https://fr.wikipedia.org/wiki/Mod%C3%A8le-vue-contr%C3%B4leur"><abbr title="Modèle-Vue-Contrôleur">MVC</abbr></a> complet ; ils visent en particulier à éviter les redondances dans le code des routes, qui doivent se contenter d'appeler un contrôleur associé.</p>
    <p>Bien qu'il ne soit pas un contrôleur à proprement parler, le fonctionnement de <code>routes/factory</code> sera documenté ici, car son cadre de réutilisation est similaire à celui des contrôleurs.</p>
    <h2>Contrôleurs POST et PATCH</h2>
    <p>Les deux contrôleurs POST et PATCH ont une structure très simple et reposent en grande partie sur un contrôleur connexe : le <code>bodyParser</code>, chargé de vérifier que le contenu du corps de la requête correspond bien au modèle.</p>
    <p>Globalement, ces deux contrôleurs tentent de récupérer les arguments de la requête via ce parseur, puis exécutent la méthode correspondante en base de données (UPDATE pour PATCH et INSERT pour POST), et retournent l'élément inséré ou modifié ; c'est pourquoi le PATCH exécute deux requêtes : une pour modifier les données, et une pour récupérer les données modifiées.</p>
    <p>Ces deux contrôleurs ne prennent qu'un seul argument : <code>model</code>, qui est le modèle à traiter ; tous les autres arguments, s'il y en a, seront passés au <code>bodyParser</code>. Ce parseur, plutôt complexe mais très modulaire, accepte quant à lui les paramètres suivants :</p>
    <ul>
      <li><code>model</code> : modèle de la base de données à traiter ;</li>
      <li><code>optionalFields</code> : champs optionnels du modèle, qui seront insérés automatiquement s'ils sont absents ; cela concerne en particulier les champs <code>createdAt</code> et <code>updatedAt</code>, qui ne sont pas obligatoires dans une requête ;</li>
      <li><code>inject</code> : liste clef : valeur de paramètres fictifs rajoutés au contenu du corps de la requête avant traitement. La clef est le nom du paramètre, la valeur est une chaine de caractères à insérer, ou une fonction retournant une chaine de caractères ;</li>
      <li><code>strict</code> : précise si une erreur est renvoyée lorsqu'un ou plusieurs des paramètres du modèle, hormis ceux mentionnés dans <code>optionalFields</code>, sont absents ; le mode strict est activé par défaut, mais n'est pas utile pour les requêtes <em>PATCH</em> par exemple.</li>
    </ul>
    <h2>Contrôleurs GET</h2>
    <p>Deux contrôleurs coexistent pour la méthode <em>GET</em> ; l'un permet de filtrer une collection de données, quand l'autre accède à un élément individuel de la collection (une ressource membre). Ces deux contrôleurs semblent complexes parce qu'ils construisent des liens absolus, mais sont en réalité très simples d'utilisation. Les paramètres possibles sont les suivants :</p>
    <ul>
      <li><code>model</code> : modèle de la base de données à traiter ;</li>
      <li><code>find</code> : paramètres passés à la méthode <a href="https://sequelize.org/v5/class/lib/model.js~Model.html#static-method-findAll"><code>find*</code></a> de Sequelize pour filtrer les résultats ; certains paramètres sont forcés par le contrôleur, en particulier pour la pagination ou l'ordonnancement ;</li>
      <li>(collection uniquement) <code>pageSize</code> : la taille de page par défaut pour le filtrage des données ;</li>
      <li>(collection uniquement) <code>removeModelUrl</code> : ne pas retourner les liens des ressources enfant ;</li>
      <li>(ressource uniquement) <code>include</code> : modèles dépendants à inclure dans le corps de la réponse ;</li>
      <li>(ressource uniquement) <code>unifyMultipleLinks</code> : pour les modèles dépendants multiples, les regrouper en un seul lien au lieu d'une collection.</li>
    </ul>
    <p>Le contrôleur de collection se base en outre sur les paramètres de la requête pour filtrer les résultats ; les <em>query strings</em> suivants sont utilisés pour faire du filtrage :</p>
    <ul>
      <li><code>page</code> : numéro de la page à consulter ;</li>
      <li><code>page_size</code> : nombre d'éléments par page ;</li>
      <li><code>start</code> : filtrage chronologique : données après cette date uniquement ;</li>
      <li><code>end</code> : filtrage chronologique : données avant cette date uniquement.</li>
    </ul>
    <h2>Paramètres du DELETE</h2>
    <p>Le contrôleur <em>DELETE</em> est extrêmement simple : il supprime la ressource donnée ; seuls deux paramètres sont possibles :</p>
    <ul>
      <li><code>model</code> : modèle de la base de données à traiter ;</li>
      <li><code>deleteAll</code> : booléen indiquant de supprimer <strong>toute la collection</strong> plutôt qu'une seule ressource.</li>
    </ul>
    <h2>Constructeur de routes</h2>
    <p>Le constructeur de routes (<code>routes/factory</code>) n'est pas un contrôleur à proprement parler, mais fait appel aux contrôleurs pour créer automatiquement toutes les routes liées à un modèle ; il est actuellement utilisé pour environ 90% des routes, ce qui permet d'éviter le code redondant. Il possède les paramètres suivants :</p>
    <ul>
      <li><code>model</code> : modèle de la base de données à traiter ;</li>
      <li><code>router</code> : routeur à utiliser comme base des requêtes ;</li>
      <li><code>optionalFields</code> : champs optionnels du modèle, qui seront insérés automatiquement s'ils sont absents lors des POST ; les champs <code>id</code>, <code>createdAt</code> et <code>updatedAt</code> sont ajoutés automatiquement, il est donc inutile de les mettre manuellement, sauf dans les cas ou la date de création est différente de la date actuelle (cas des données des capteurs).</li>
    </ul>
    <p>Depuis ces informations, les modèles enfants sont immédiatement récupérés et pris en compte lors des requêtes <em>GET</em>.</p>
  </body>
</html>
